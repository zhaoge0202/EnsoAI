import * as fs from 'node:fs';
import * as os from 'node:os';
import * as path from 'node:path';
import { app } from 'electron';

interface StatusLineConfig {
  type: 'command' | 'text';
  command?: string;
  text?: string;
  padding?: number;
}

interface ClaudeSettings {
  hooks?: {
    Stop?: Array<{
      matcher?: string;
      hooks: Array<{
        type: 'command' | 'prompt';
        command?: string;
        prompt?: string;
        timeout?: number;
      }>;
    }>;
    [key: string]: unknown;
  };
  statusLine?: StatusLineConfig;
  [key: string]: unknown;
}

interface StatusLineBackup {
  originalConfig: StatusLineConfig | null;
  backupTime: string;
}

// Hook is identified by the script path 'ensoai-stop.js' in the command

function getClaudeConfigDir(): string {
  if (process.env.CLAUDE_CONFIG_DIR) {
    return process.env.CLAUDE_CONFIG_DIR;
  }
  return path.join(os.homedir(), '.claude');
}

function getClaudeSettingsPath(): string {
  return path.join(getClaudeConfigDir(), 'settings.json');
}

function getHooksDir(): string {
  return path.join(getClaudeConfigDir(), 'hooks');
}

function getHookScriptPath(): string {
  return path.join(getHooksDir(), 'ensoai-stop.js');
}

/**
 * Node.js hook script content - runs on all platforms
 */
function getHookScriptContent(): string {
  const ideDir = path.join(getClaudeConfigDir(), 'ide');
  // Use forward slashes for path in JS (works on all platforms)
  const ideDirJs = ideDir.replace(/\\/g, '/');

  return `// EnsoAI Stop Hook - Sends precise agent completion notifications
// Auto-generated by EnsoAI - Do not edit manually
// Requires Node.js in PATH

const fs = require('fs');
const path = require('path');
const http = require('http');

const IDE_DIR = '${ideDirJs}';

async function main() {
  // Read JSON from stdin
  let input = '';
  process.stdin.setEncoding('utf8');
  for await (const chunk of process.stdin) {
    input += chunk;
  }

  let sessionId;
  try {
    const data = JSON.parse(input);
    sessionId = data.session_id;
  } catch {
    process.exit(0);
  }

  if (!sessionId) {
    process.exit(0);
  }

  // Find EnsoAI lockfile
  if (!fs.existsSync(IDE_DIR)) {
    process.exit(0);
  }

  const lockfiles = fs.readdirSync(IDE_DIR).filter(f => f.endsWith('.lock'));
  for (const lockfile of lockfiles) {
    try {
      const content = JSON.parse(fs.readFileSync(path.join(IDE_DIR, lockfile), 'utf-8'));
      if (content.ideName === 'EnsoAI') {
        const port = path.basename(lockfile, '.lock');
        // Send POST request
        const postData = JSON.stringify({ session_id: sessionId });
        const req = http.request({
          hostname: '127.0.0.1',
          port: parseInt(port),
          path: '/agent-stop',
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Content-Length': Buffer.byteLength(postData),
          },
          timeout: 2000,
        });
        req.on('error', () => {});
        req.write(postData);
        req.end();
        break;
      }
    } catch {
      // Ignore errors, try next lockfile
    }
  }
}

main().catch(() => process.exit(0));
`;
}

/**
 * Ensure hook script file exists
 */
function ensureHookScript(): string {
  const hooksDir = getHooksDir();
  const scriptPath = getHookScriptPath();

  // Create hooks directory if needed
  if (!fs.existsSync(hooksDir)) {
    fs.mkdirSync(hooksDir, { recursive: true, mode: 0o755 });
  }

  // Write script file
  fs.writeFileSync(scriptPath, getHookScriptContent(), { mode: 0o755 });

  return scriptPath;
}

/**
 * Generate hook command that runs the script using Node.js
 * Requires Node.js to be installed and available in PATH
 */
function generateHookCommand(): string {
  const scriptPath = getHookScriptPath();
  // Use forward slashes for cross-platform compatibility
  const scriptPathCmd = scriptPath.replace(/\\/g, '/');

  return `node "${scriptPathCmd}"`;
}

/**
 * Check if EnsoAI Stop hook is already configured
 * Identifies our hook by the ensoai-stop.js script path
 */
function isHookConfigured(settings: ClaudeSettings): boolean {
  const stopHooks = settings.hooks?.Stop;
  if (!Array.isArray(stopHooks)) return false;

  return stopHooks.some((hookGroup) =>
    hookGroup.hooks?.some(
      (hook) => hook.type === 'command' && hook.command?.includes('ensoai-stop.js')
    )
  );
}

/**
 * Check if Claude CLI is installed by verifying .claude directory exists
 * This prevents creating config files for users who don't have Claude installed
 */
export function isClaudeInstalled(): boolean {
  const configDir = getClaudeConfigDir();
  return fs.existsSync(configDir);
}

/**
 * Ensure the Stop hook is configured in Claude settings
 * Returns true if hook was added or already exists
 * Returns false if Claude is not installed (skips setup)
 */
export function ensureStopHook(): boolean {
  // Skip hook setup if Claude is not installed
  if (!isClaudeInstalled()) {
    console.log('[ClaudeHookManager] Claude not installed, skipping hook setup');
    return false;
  }

  try {
    // Always ensure script file is up-to-date
    ensureHookScript();

    const settingsPath = getClaudeSettingsPath();

    // Read existing settings or create new
    let settings: ClaudeSettings = {};
    if (fs.existsSync(settingsPath)) {
      const content = fs.readFileSync(settingsPath, 'utf-8');
      settings = JSON.parse(content);
    }

    // Check if already configured
    if (isHookConfigured(settings)) {
      return true;
    }

    // Initialize hooks object if needed
    if (!settings.hooks) {
      settings.hooks = {};
    }
    if (!settings.hooks.Stop) {
      settings.hooks.Stop = [];
    }

    // Add our hook - marker is embedded in the command for identification
    const hookCommand = generateHookCommand();
    settings.hooks.Stop.push({
      matcher: '',
      hooks: [
        {
          type: 'command',
          // Marker is checked via includes(HOOK_MARKER), embedded in command itself
          command: hookCommand,
          timeout: 5,
        },
      ],
    });

    // Ensure directory exists
    const configDir = getClaudeConfigDir();
    if (!fs.existsSync(configDir)) {
      fs.mkdirSync(configDir, { recursive: true, mode: 0o700 });
    }

    // Write settings
    fs.writeFileSync(settingsPath, JSON.stringify(settings, null, 2), {
      mode: 0o600,
    });

    console.log('[ClaudeHookManager] Stop hook configured successfully');
    return true;
  } catch (error) {
    console.error('[ClaudeHookManager] Failed to configure Stop hook:', error);
    return false;
  }
}

/**
 * Remove EnsoAI Stop hook from Claude settings
 */
export function removeStopHook(): boolean {
  try {
    const settingsPath = getClaudeSettingsPath();

    if (!fs.existsSync(settingsPath)) {
      return true;
    }

    const content = fs.readFileSync(settingsPath, 'utf-8');
    const settings: ClaudeSettings = JSON.parse(content);

    if (!settings.hooks?.Stop) {
      return true;
    }

    // Filter out our hooks (identified by ensoai-stop.js script path)
    settings.hooks.Stop = settings.hooks.Stop.filter(
      (hookGroup) =>
        !hookGroup.hooks?.some(
          (hook) => hook.type === 'command' && hook.command?.includes('ensoai-stop.js')
        )
    );

    // Clean up empty arrays
    if (settings.hooks.Stop.length === 0) {
      delete settings.hooks.Stop;
    }
    if (Object.keys(settings.hooks).length === 0) {
      delete settings.hooks;
    }

    fs.writeFileSync(settingsPath, JSON.stringify(settings, null, 2), {
      mode: 0o600,
    });

    console.log('[ClaudeHookManager] Stop hook removed successfully');
    return true;
  } catch (error) {
    console.error('[ClaudeHookManager] Failed to remove Stop hook:', error);
    return false;
  }
}

// ============================================================================
// Status Line Hook Management
// ============================================================================

const STATUSLINE_SCRIPT_NAME = 'enso-statusline.js';
const STATUSLINE_BACKUP_FILE = 'claude-statusline-backup.json';

function getStatusLineScriptPath(): string {
  return path.join(getHooksDir(), STATUSLINE_SCRIPT_NAME);
}

function getStatusLineBackupPath(): string {
  return path.join(app.getPath('userData'), STATUSLINE_BACKUP_FILE);
}

/**
 * Generate status line script content
 */
function getStatusLineScriptContent(): string {
  const ideDir = path.join(getClaudeConfigDir(), 'ide');
  const ideDirJs = ideDir.replace(/\\/g, '/');

  return `// EnsoAI Status Line Hook - Forwards status data to EnsoAI
// Auto-generated by EnsoAI - Do not edit manually

const fs = require('fs');
const path = require('path');
const http = require('http');

const IDE_DIR = '${ideDirJs}';

async function main() {
  // Read JSON from stdin
  let input = '';
  process.stdin.setEncoding('utf8');
  for await (const chunk of process.stdin) {
    input += chunk;
  }

  let data;
  try {
    data = JSON.parse(input);
  } catch {
    // Output empty line if parsing fails
    console.log('');
    process.exit(0);
  }

  // Find EnsoAI lockfiles and send status update to ALL instances
  if (fs.existsSync(IDE_DIR)) {
    const lockfiles = fs.readdirSync(IDE_DIR).filter(f => f.endsWith('.lock'));
    for (const lockfile of lockfiles) {
      try {
        const content = JSON.parse(fs.readFileSync(path.join(IDE_DIR, lockfile), 'utf-8'));
        if (content.ideName === 'EnsoAI') {
          const port = path.basename(lockfile, '.lock');
          const postData = JSON.stringify(data);
          const req = http.request({
            hostname: '127.0.0.1',
            port: parseInt(port),
            path: '/status-line',
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Content-Length': Buffer.byteLength(postData),
            },
            timeout: 1000,
          });
          req.on('error', () => {});
          req.write(postData);
          req.end();
          // Don't break - send to all EnsoAI instances
        }
      } catch {
        // Ignore errors, try next lockfile
      }
    }
  }

  // Output empty line - don't override Claude's native status line display
  console.log('');
}

main().catch(() => {
  console.log('');
  process.exit(0);
});
`;
}

/**
 * Ensure status line script file exists
 */
function ensureStatusLineScript(): string {
  const hooksDir = getHooksDir();
  const scriptPath = getStatusLineScriptPath();

  if (!fs.existsSync(hooksDir)) {
    fs.mkdirSync(hooksDir, { recursive: true, mode: 0o755 });
  }

  fs.writeFileSync(scriptPath, getStatusLineScriptContent(), { mode: 0o755 });
  return scriptPath;
}

/**
 * Generate status line command
 */
function generateStatusLineCommand(): string {
  const scriptPath = getStatusLineScriptPath();
  const scriptPathCmd = scriptPath.replace(/\\/g, '/');
  return `node "${scriptPathCmd}"`;
}

/**
 * Check if our status line hook is configured
 */
function isStatusLineHookConfigured(settings: ClaudeSettings): boolean {
  return (
    settings.statusLine?.type === 'command' &&
    (settings.statusLine?.command?.includes(STATUSLINE_SCRIPT_NAME) ?? false)
  );
}

/**
 * Backup existing status line config
 */
function backupStatusLineConfig(currentConfig: StatusLineConfig | undefined): void {
  const backupPath = getStatusLineBackupPath();

  // Don't backup if already backed up
  if (fs.existsSync(backupPath)) {
    return;
  }

  const backup: StatusLineBackup = {
    originalConfig: currentConfig ?? null,
    backupTime: new Date().toISOString(),
  };

  const userDataDir = app.getPath('userData');
  if (!fs.existsSync(userDataDir)) {
    fs.mkdirSync(userDataDir, { recursive: true });
  }

  fs.writeFileSync(backupPath, JSON.stringify(backup, null, 2), { mode: 0o600 });
  console.log('[ClaudeHookManager] Status line config backed up');
}

/**
 * Restore status line config from backup
 */
function restoreStatusLineConfig(): StatusLineConfig | null | undefined {
  const backupPath = getStatusLineBackupPath();

  if (!fs.existsSync(backupPath)) {
    return undefined; // No backup exists
  }

  try {
    const content = fs.readFileSync(backupPath, 'utf-8');
    const backup: StatusLineBackup = JSON.parse(content);

    // Delete backup file after reading
    fs.unlinkSync(backupPath);

    console.log('[ClaudeHookManager] Status line config restored from backup');
    return backup.originalConfig;
  } catch (error) {
    console.error('[ClaudeHookManager] Failed to restore status line backup:', error);
    return undefined;
  }
}

/**
 * Ensure status line hook is configured
 */
export function ensureStatusLineHook(): boolean {
  if (!isClaudeInstalled()) {
    console.log('[ClaudeHookManager] Claude not installed, skipping status line hook setup');
    return false;
  }

  try {
    // Ensure script file is up-to-date
    ensureStatusLineScript();

    const settingsPath = getClaudeSettingsPath();

    let settings: ClaudeSettings = {};
    if (fs.existsSync(settingsPath)) {
      const content = fs.readFileSync(settingsPath, 'utf-8');
      settings = JSON.parse(content);
    }

    // Already configured
    if (isStatusLineHookConfigured(settings)) {
      return true;
    }

    // Backup existing config
    backupStatusLineConfig(settings.statusLine);

    // Set our status line config
    settings.statusLine = {
      type: 'command',
      command: generateStatusLineCommand(),
      padding: 0,
    };

    const configDir = getClaudeConfigDir();
    if (!fs.existsSync(configDir)) {
      fs.mkdirSync(configDir, { recursive: true, mode: 0o700 });
    }

    fs.writeFileSync(settingsPath, JSON.stringify(settings, null, 2), { mode: 0o600 });
    console.log('[ClaudeHookManager] Status line hook configured successfully');
    return true;
  } catch (error) {
    console.error('[ClaudeHookManager] Failed to configure status line hook:', error);
    return false;
  }
}

/**
 * Remove status line hook and restore original config
 */
export function removeStatusLineHook(): boolean {
  try {
    const settingsPath = getClaudeSettingsPath();

    if (!fs.existsSync(settingsPath)) {
      return true;
    }

    const content = fs.readFileSync(settingsPath, 'utf-8');
    const settings: ClaudeSettings = JSON.parse(content);

    // Only remove if it's our hook
    if (!isStatusLineHookConfigured(settings)) {
      return true;
    }

    // Restore from backup
    const originalConfig = restoreStatusLineConfig();

    if (originalConfig === undefined) {
      // No backup, just delete our config
      delete settings.statusLine;
    } else if (originalConfig === null) {
      // Original had no config
      delete settings.statusLine;
    } else {
      // Restore original config
      settings.statusLine = originalConfig;
    }

    fs.writeFileSync(settingsPath, JSON.stringify(settings, null, 2), { mode: 0o600 });

    // Remove script file
    const scriptPath = getStatusLineScriptPath();
    if (fs.existsSync(scriptPath)) {
      fs.unlinkSync(scriptPath);
    }

    console.log('[ClaudeHookManager] Status line hook removed successfully');
    return true;
  } catch (error) {
    console.error('[ClaudeHookManager] Failed to remove status line hook:', error);
    return false;
  }
}

/**
 * Check if status line hook is installed
 */
export function isStatusLineHookInstalled(): boolean {
  try {
    const settingsPath = getClaudeSettingsPath();
    if (!fs.existsSync(settingsPath)) {
      return false;
    }

    const content = fs.readFileSync(settingsPath, 'utf-8');
    const settings: ClaudeSettings = JSON.parse(content);
    return isStatusLineHookConfigured(settings);
  } catch {
    return false;
  }
}
